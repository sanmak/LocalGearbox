/*
 * Copyright (c) 2025 LocalGearbox. All rights reserved.
 * Licensed under the MIT License. See LICENSE file in the project root for details.
 */

'use client';

/**
 * JSON to Go Struct Converter
 * Generate Go struct definitions from JSON data
 */

import { ToolLayout } from '@/components/ToolLayout';

// Convert string to PascalCase for Go exported names
function toPascalCase(str: string): string {
  return str
    .replace(/[-_\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : ''))
    .replace(/^(.)/, (_, c) => c.toUpperCase());
}

// Convert string to valid Go identifier
function toGoIdentifier(str: string): string {
  const pascal = toPascalCase(str);
  // Handle common acronyms
  return pascal
    .replace(/Id$/g, 'ID')
    .replace(/Url$/g, 'URL')
    .replace(/Uri$/g, 'URI')
    .replace(/Api$/g, 'API')
    .replace(/Http$/g, 'HTTP')
    .replace(/Html$/g, 'HTML')
    .replace(/Json$/g, 'JSON')
    .replace(/Xml$/g, 'XML')
    .replace(/Sql$/g, 'SQL')
    .replace(/Uuid$/g, 'UUID');
}

interface StructInfo {
  name: string;
  fields: Map<string, { goType: string; jsonTag: string }>;
}

function inferGoType(
  value: unknown,
  key: string,
  structs: Map<string, StructInfo>,
  visited: WeakSet<object>,
): string {
  if (value === null) {
    return 'interface{}';
  }

  switch (typeof value) {
    case 'string':
      return 'string';
    case 'number':
      return Number.isInteger(value) ? 'int' : 'float64';
    case 'boolean':
      return 'bool';
    case 'object':
      if (Array.isArray(value)) {
        if (value.length === 0) {
          return '[]interface{}';
        }

        // Check if all items are the same type
        const types = new Set<string>();
        let hasObjects = false;

        for (const item of value) {
          if (typeof item === 'object' && item !== null && !Array.isArray(item)) {
            hasObjects = true;
          } else {
            types.add(inferGoType(item, key, structs, visited));
          }
        }

        if (hasObjects) {
          // Generate struct for array items
          const structName = toGoIdentifier(key);
          generateStruct(value[0], structName, structs, visited);
          return `[]${structName}`;
        }

        if (types.size === 1) {
          return `[]${[...types][0]}`;
        }

        return '[]interface{}';
      }

      // Regular object - generate struct
      const structName = toGoIdentifier(key);
      generateStruct(value, structName, structs, visited);
      return structName;

    default:
      return 'interface{}';
  }
}

function generateStruct(
  obj: unknown,
  name: string,
  structs: Map<string, StructInfo>,
  visited: WeakSet<object>,
): void {
  if (obj === null || typeof obj !== 'object' || Array.isArray(obj)) {
    return;
  }

  if (visited.has(obj as object)) {
    return;
  }
  visited.add(obj as object);

  // Skip if struct with same name already exists
  if (structs.has(name)) {
    return;
  }

  const structInfo: StructInfo = {
    name,
    fields: new Map(),
  };

  const entries = Object.entries(obj as Record<string, unknown>);

  for (const [key, value] of entries) {
    const fieldName = toGoIdentifier(key);
    const goType = inferGoType(value, fieldName, structs, visited);
    const jsonTag = `\`json:"${key}"\``;
    structInfo.fields.set(fieldName, { goType, jsonTag });
  }

  structs.set(name, structInfo);
}

function structsToString(structs: Map<string, StructInfo>): string {
  const result: string[] = [];

  // Sort structs so AutoGenerated/Root comes first
  const sortedEntries = [...structs.entries()].sort(([a], [b]) => {
    if (a === 'AutoGenerated' || a === 'Root') return -1;
    if (b === 'AutoGenerated' || b === 'Root') return 1;
    return a.localeCompare(b);
  });

  for (const [, info] of sortedEntries) {
    const lines: string[] = [];
    lines.push(`type ${info.name} struct {`);

    // Find max field name length for alignment
    let maxFieldLen = 0;
    let maxTypeLen = 0;
    for (const [fieldName, { goType }] of info.fields) {
      maxFieldLen = Math.max(maxFieldLen, fieldName.length);
      maxTypeLen = Math.max(maxTypeLen, goType.length);
    }

    for (const [fieldName, { goType, jsonTag }] of info.fields) {
      const paddedField = fieldName.padEnd(maxFieldLen);
      const paddedType = goType.padEnd(maxTypeLen);
      lines.push(`\t${paddedField} ${paddedType} ${jsonTag}`);
    }

    lines.push('}');
    result.push(lines.join('\n'));
  }

  return result.join('\n\n');
}

async function convertJsonToGo(input: string): Promise<string> {
  if (!input.trim()) {
    throw new Error('Input cannot be empty');
  }

  if (input.length > 10 * 1024 * 1024) {
    throw new Error('Input exceeds size limit of 10MB');
  }

  try {
    const parsed = JSON.parse(input);

    if (parsed === null) {
      return 'type AutoGenerated interface{}';
    }

    if (typeof parsed !== 'object') {
      const goType = inferGoType(parsed, 'AutoGenerated', new Map(), new WeakSet());
      return `type AutoGenerated ${goType}`;
    }

    if (Array.isArray(parsed)) {
      if (parsed.length === 0) {
        return 'type AutoGenerated []interface{}';
      }

      const structs = new Map<string, StructInfo>();
      const visited = new WeakSet<object>();

      // Check if array contains objects
      if (typeof parsed[0] === 'object' && parsed[0] !== null && !Array.isArray(parsed[0])) {
        generateStruct(parsed[0], 'AutoGenerated', structs, visited);
        const structsStr = structsToString(structs);
        return structsStr + '\n\n// Root type is []AutoGenerated';
      }

      const itemType = inferGoType(parsed[0], 'Item', structs, visited);
      return `type AutoGenerated []${itemType}`;
    }

    const structs = new Map<string, StructInfo>();
    const visited = new WeakSet<object>();
    generateStruct(parsed, 'AutoGenerated', structs, visited);
    return structsToString(structs);
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new Error(`Invalid JSON: ${error.message}`);
    }
    throw error;
  }
}

const SAMPLE_JSON = `{
  "userId": 1,
  "id": 1,
  "title": "delectus aut autem",
  "completed": false,
  "user": {
    "name": "John Doe",
    "email": "john@example.com",
    "age": 30,
    "roles": ["admin", "user"]
  },
  "tags": ["important", "urgent"],
  "metadata": null
}`;

export default function JsonToGoPage() {
  return (
    <ToolLayout
      toolName="JSON to Go Struct"
      toolDescription="Generate Go struct definitions from JSON data. Automatically infers types and creates proper json tags."
      onProcess={convertJsonToGo}
      placeholder="Paste your JSON here..."
      sampleData={SAMPLE_JSON}
      showJsonButtons={true}
    />
  );
}
